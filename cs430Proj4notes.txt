#define GLFW_INCLUDE_ES2 1
#define GLFW_DLL 1

#include<GLES2/gl2.h>
#include<GLFW/glfw3.h>

#include <stdlib.h>
#include <stdio.h>

GLFWWindow* window;

Project 4

* property: reflectivity 0.0 to 1.0
* property: refractivity 0.0 to 1.0
* property: ior (index of refraction)
* assume the raytracing depth is limited to 7

//Vertex shader (this is not C code; this is GLSL)

char* vertex_shader_src = 
"attribute vec4 Position;\n"			//attribute is modifier; vec4 is type (vector of 4 tuples floats); Position is variable name
"attribute vec4 SourceColor;\n"			//vec4 bc RGBA
"\n"
"varying vec4 DestinationColor;\n"		//varying is output attribute
"\n
"void main(void){\n"					//pass in void to express no arguments being passed in
	"DestinationColor = SourceColor;\n"
	"gl_Position = Position;\n"			//gl_Position is built-in variable
"}\n";

//Fragment shader(GLSL code)

//lowp - lower precision but faster (framerate)
//mediump - middle ground
//highp - highest precision but slower

char* fragment_shader_src = 
"varying lowp vec4 DestinationColor;\n"		//variable name and type has to match that of vertex shader
"\n"
"void main(void){\n"
	"gl_FragColor = DestinationColor;\n"
"}\n"

typedef struct{
	float position[3];
	float color[4];
} Vertex;

Vertex verticies[] = {
	{{1, 1, 0}, {1, 0, 0, 1}},
	{{1, 1, 0}, {0, 1, 0, 1}},
	{{-1, 1, 0}, {0, 0, 1, 1}},
	{{-1, -1, 0}, {0, 0, 0, 1}}
};

GLubyte indicies[] = {
	0, 1, 2,
	2, 3, 0
};

//compile our shader
GLuint simple_shader(GLint shader_type, char* shader_src){
	GLint compile_success = 0;
	
	GLuint shader_id = glCreateShader(shader_type);
	
	glShaderSource(shader_id, 1, &shader_src, 0);
	
	glCompileShader(shader_id);
	
	glGetShaderiv(shader_id, GL_COMPILE_STATUS, &compile_success);	//iv = integer value
	
	if(compile_success == GL_FALSE){
		GLchar message[256];
		glGetShaderInfoLog(shader_id, sizeof(message), 0, &&message[0]);
		printf("glCompileShaderError: %s\n", message);
		exit(1);
	}
	
	return shader_id;
}

GLuint simple_program(){
	GLint link_success = 0;
	
	GLuint program_id = flCreateProgram();
	GLuint vertex_shader = simple_shader(GL_VERTEX_SHADER, vertex_shader_src);
	GLuint fragment_shader = simple_shader(GL_FRAGMENT_SHADER, fragment_shader_src);
	
	glAttachShader(program_id, vertex_shader);
	glAttachShader(program_id, fragment_shader);
	
	glLinkProgram(program_id);
	
	glGetProgramiv(program_id, GL_LINK_STATUS, &link_success);
	
	if(link_success == GL_FALSE){		//create error function 
		GLchar message[256];
		glGetProgramInfoLog(program_id, sizeof(message), 0, &&message[0]);
		printf("glLinkProgramError: %s\n", message);
		exit(1);
	}
	
	return program_id;
}

static void error_callback(int error, char* description){
	printf("GLFW Error (%d): %s\n", error, description);
}

int main(){
	GLint program_id, position_slot, color_slot;
	GLuint vertex_buffer;
	GLuint index_buffer;
	
	glfwSetErrorCallback(error_callback);
	
	if(!glfwInit()) return -1;
	
	
}